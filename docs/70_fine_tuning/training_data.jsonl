{"messages": [{"role": "user", "content": "def rotate_image_by_90_degrees(image):\n    \"\"\"\n    Rotates an image by 90 degrees clockwise around the center of the image.\n    \"\"\""}, {"role": "assistant", "content": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}]}
{"messages": [{"role": "user", "content": "def measure_intensity_of_labels(label_image, intensity_image):\n    \"\"\"\n    Takes a label image and an intensity image, and returns a list of mean intensities \n    of all pixels in the intensity image, belonging to a given label.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}]}
{"messages": [{"role": "user", "content": "def count_objects_over_time(binary_image_list):\n    \"\"\"\n    Takes a timelapse (list of binary images), counts the number of connected components and returns the resulting counts as list.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}]}
{"messages": [{"role": "user", "content": "def label_binary_image_and_count_labels(binary_image):\n    \"\"\"\n    Consumes as input a binary image, applies connected component labeling to it, \n    counts the labeled objects and returns their count as single number.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}]}
{"messages": [{"role": "user", "content": "def convolve_images(image, kernel_image):\n    \"\"\"\n    Convolve an image with a kernel_image and return the result\n    \"\"\""}, {"role": "assistant", "content": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}]}
{"messages": [{"role": "user", "content": "def combine_columns_of_tables(dataframe1, dataframe2, index):\n    \"\"\"\n    This function combines to dataframes and makes sure the data is merged \n    using the given index column, which must be present in both dataframes.\n    The dataframes should be merged in a way that no data is lost and missing\n    fields are filled with NaN.\n    \"\"\""}, {"role": "assistant", "content": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}]}
{"messages": [{"role": "user", "content": "def remove_small_labels(label_image, size_threshold:int=0):\n    \"\"\"\n    Takes a label_image and removes all objects that are smaller than a given size_threshold.\n    \"\"\""}, {"role": "assistant", "content": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}]}
{"messages": [{"role": "user", "content": "def list_image_files_in_folder(folder_location):\n    \"\"\"\n    Lists all image files in a folder.\n    \"\"\""}, {"role": "assistant", "content": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}]}
{"messages": [{"role": "user", "content": "def radial_intensity_profile(image, xc, yc):\n    \"\"\"\n    Computes the radial intensity profile of an image around a given coordinate\n    Inputs:\n    - image: 2d numpy array\n    - xy, yc: the center coordinates\n    Output:\n    - an array containing the average intensities\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}]}
{"messages": [{"role": "user", "content": "def tiled_image_processing(image, radius, tile_size):\n    \"\"\"\n    Apply a maximum filter with a given radius to the image using a tile-by-tile strategy.\n    The tile_size denotes the size of the tiles in X and Y.\n    \"\"\""}, {"role": "assistant", "content": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}]}
{"messages": [{"role": "user", "content": "def region_growing_segmentation(image, point):\n    \"\"\"\n    Segments an image using the region-growing/flood filling \n    starting from a single point.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}]}
{"messages": [{"role": "user", "content": "def workflow_segmentation_counting(image):\n    \"\"\"\n    This function segments objects in an image with intensity above average \n    and returns their count.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}]}
{"messages": [{"role": "user", "content": "def extract_surface_measure_area(binary_volume_image):\n    \"\"\"\n    Take a 3D binary_volume_image, extracts the surface of the white (voxel value != 0) object \n    and returns the surface area of the object.\n    \"\"\""}, {"role": "assistant", "content": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}]}
{"messages": [{"role": "user", "content": "def count_overlapping_regions(label_image_1, label_image_2):\n    \"\"\"\n    Takes two label images and counts how many objects in label_image_1 overlap \n    with any label in label_image_2 with at least one pixel.\n    It returns the count of overlapping objects.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}]}
{"messages": [{"role": "user", "content": "def fit_circle(list_of_2d_points):\n    \"\"\"\n    Implements 2D circle fitting\n    Input: Collection of 2d points, represented as a list of lists [ [x0,y0], [x1,y1], ... ]  \n    Output: Tuple: xc, yc, radius\n    \"\"\""}, {"role": "assistant", "content": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}]}
{"messages": [{"role": "user", "content": "def mean_std_column(dataframe, column:str):\n    \"\"\"\n    Computes the mean average and standard deviation of a specified column \n    in a given dataframe and returns these two values.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}]}
{"messages": [{"role": "user", "content": "def open_nifti_image(image_file_location):\n    \"\"\"\n    This function loads a nifti image from the file at image_location and returns the image data as a numpy array. \n    \"\"\""}, {"role": "assistant", "content": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}]}
{"messages": [{"role": "user", "content": "def workflow_segmentation_measurement_summary(image):\n    \"\"\"\n    This function implements a workflow consisting of these steps:\n    * threshold intensity input image using Otsu's method\n    * label connected components\n    * measure area of the labeled objects\n    * determine mean area of all objects\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}]}
{"messages": [{"role": "user", "content": "def workflow_batch_process_folder_measure_intensity(image_folder_location, labels_folder_location):\n    \"\"\"\n    This functions goes through all .tif image files in a specified image folder \n    and corresponding label images in another labels folder. \n    It loads the images and corresponding labels, and measures min, mean and max intensity of all labels.\n    The function returns a dataframe with five columns: min_intensity, mean_intensity, max_intensity, label and filename.\n    \"\"\""}, {"role": "assistant", "content": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}]}
{"messages": [{"role": "user", "content": "def measure_aspect_ratio_of_regions(label_image):\n    \"\"\"\n    Takes a label image and returns a pandas dataframe\n    with measurements for aspect_ratio of the objects\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}]}
{"messages": [{"role": "user", "content": "def crop_quarter_image(image):\n    \"\"\"\n    Crops out the first half image in both dimensions (width and height). \n    The resulting image will be of quarter size compared to the original image.\n    \"\"\""}, {"role": "assistant", "content": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}]}
{"messages": [{"role": "user", "content": "def open_image_return_dimensions(image_file_location):\n    \"\"\"\n    Opens an image and returns its dimensions\n    \"\"\""}, {"role": "assistant", "content": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}]}
{"messages": [{"role": "user", "content": "def t_test(dataframe, column1:str, column2:str):\n    \"\"\"\n    Takes two specified columns from a given dataframe and applies a paired T-test to it to determine the p-value.\n    \"\"\""}, {"role": "assistant", "content": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}]}
{"messages": [{"role": "user", "content": "def transpose_image_axes(image):\n    \"\"\"\n    Transposes the first two axes of an image.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    return np.asarray(image).T"}]}
{"messages": [{"role": "user", "content": "def measure_pixel_count_of_labels(label_image):\n    \"\"\"\n    Takes a label image and returns a list of counts of number of pixels per label.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}]}
{"messages": [{"role": "user", "content": "def return_hello_world():\n    \"\"\"\n    Returns the string \"hello world\".\n    \"\"\""}, {"role": "assistant", "content": "\n    return \"hello world\""}]}
{"messages": [{"role": "user", "content": "def binary_closing(binary_image, radius:int=1):\n    \"\"\"\n    Applies binary closing to a binary_image with a square footprint with a given radius.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}]}
{"messages": [{"role": "user", "content": "def mask_image(image, mask):\n    \"\"\"\n    Takes a 2D input image and a 2D binary mask image, then applies the mask to the input image and returns the result.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}]}
{"messages": [{"role": "user", "content": "def binary_skeleton(binary_image):\n    \"\"\"\n    Applies skeletonization to a 2D binary image.\n    \"\"\""}, {"role": "assistant", "content": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}]}
{"messages": [{"role": "user", "content": "def subsample_image(image, n:int=2):\n    \"\"\"\n    Subsamples an image by skipping every n'th pixel in X and Y.\n    \"\"\""}, {"role": "assistant", "content": "\n    return image[::n,::n]"}]}
{"messages": [{"role": "user", "content": "def remove_noise_edge_preserving(image, radius:int=1):\n    \"\"\"\n    Applies an edge-preserving noise-removal filter to an image.\n    \"\"\""}, {"role": "assistant", "content": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}]}
{"messages": [{"role": "user", "content": "def pair_wise_correlation_matrix(dataframe):\n    \"\"\"\n    Takes a pandas dataframe and computes for all columns their Pearson's correlation coefficient\n    for all columns in the dataframe. For n columns, this is a n x n matrix of coefficients.\n    The matrix is returned as dataframe.\n    \"\"\""}, {"role": "assistant", "content": "\n    return dataframe.corr()"}]}
{"messages": [{"role": "user", "content": "def mean_squared_error(image1, image2):\n    \"\"\"\n    Computes the mean-squared-error of two images compared pixel-by-pixel\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}]}
{"messages": [{"role": "user", "content": "def sum_images(image1, image2):\n    \"\"\"\n    Sums two images pixel-by-pixel and returns the result\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}]}
{"messages": [{"role": "user", "content": "def create_umap(dataframe):\n    \"\"\"\n    Takes a dataframe and computes a UMAP from all columns. \n    The two UMAP vectors are stored in the dataframe as `umap0` and `umap1`.\n    \"\"\""}, {"role": "assistant", "content": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}]}
{"messages": [{"role": "user", "content": "def maximum_intensity_projection(image):\n    \"\"\"\n    Performs a maximum intensity projection along the first axis of an image.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}]}
{"messages": [{"role": "user", "content": "def label_sequentially(label_image):\n    \"\"\"\n    Takes a label_image with n labels and relabels the objects, \n    to make sure all integer labels between 0 and n are used. \n    No gaps are there.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}]}
{"messages": [{"role": "user", "content": "def workflow_watershed_segmentation_correction_measurement(image):\n    \"\"\"\n    This function implements a workflow consisting of these steps:\n    * blurs the image a bit\n    * detect local minima in the blurred image\n    * apply watershed segmentation flooding the blurred image from the \n      detected minima to retrieve a label image\n    * remove all objects which touch the image border\n    * measure the area of all remaining objects together\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}]}
{"messages": [{"role": "user", "content": "def map_pixel_count_of_labels(label_image):\n    \"\"\"\n    Takes a label_image, determines the pixel-count per label and creates an image where the label values are replaced by the corresponding pixel count.\n    \"\"\""}, {"role": "assistant", "content": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}]}
{"messages": [{"role": "user", "content": "def count_number_of_touching_neighbors(label_image):\n    \"\"\"\n    Takes a label image and returns a list of number of touching neighbors \n    for each labeled object.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}]}
{"messages": [{"role": "user", "content": "def rgb_to_grey_image_transform(rgb_image, r:float, g:float, b:float):\n    \"\"\"\n    Convert an RGB image to a single-channel gray scale image with \n    configurable weights r, g and b.\n    The weights are normalized to be 1 in sum.\n    \"\"\""}, {"role": "assistant", "content": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}]}
{"messages": [{"role": "user", "content": "def expand_labels_without_overlap(label_image, radius:int=1):\n    \"\"\"\n    Takes a label_image and enlarges all labels by a given radius, without\n    labels overwriting each other.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}]}
{"messages": [{"role": "user", "content": "def measure_mean_image_intensity(image):\n    \"\"\"\n    Takes an image and returns its mean intensity\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    return np.asarray(image).mean()"}]}
{"messages": [{"role": "user", "content": "def workflow_batch_process_folder_count_labels(folder_location):\n    \"\"\"\n    This functions goes through all .tif image files in a specified folder, \n    loads the images and count labels each image. \n    It returns a dictionary with filenames and corresponding counts.\n    \"\"\""}, {"role": "assistant", "content": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}]}
{"messages": [{"role": "user", "content": "def remove_labels_on_edges(label_image):\n    \"\"\"\n    Takes a label_image and removes all objects which touch the image border.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}]}
