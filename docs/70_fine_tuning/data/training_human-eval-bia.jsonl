{"task_id": "../test_cases/binary_closing.ipynb", "prompt": "def binary_closing(binary_image, radius:int=1):\n    \"\"\"\n    Applies binary closing to a binary_image with a square footprint with a given radius.\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "entry_point": "binary_closing", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,1,0,1,0,0],\n        [0,0,1,0,1,0,0],\n        [0,0,1,0,1,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n    ]))\n\n    reference = np.asarray([\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,1,1,1,0,0],\n        [0,0,1,1,1,0,0],\n        [0,0,1,1,1,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n    ])\n\n    assert np.array_equal(reference, result)"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "prompt": "def binary_skeleton(binary_image):\n    \"\"\"\n    Applies skeletonization to a 2D binary image.\n    \"\"\"", "canonical_solution": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "entry_point": "binary_skeleton", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,0,0,0,0,0],\n        [0,0,1,1,1,0,0],\n        [0,0,1,1,1,0,0],\n        [0,1,1,1,1,1,0],\n        [0,1,1,1,1,1,0],\n        [0,1,1,1,1,1,0],\n        [0,0,0,0,0,0,0],\n    ]))\n    \n    reference = np.asarray([\n        [0,0,0,0,0,0,0],\n        [0,0,0,1,0,0,0],\n        [0,0,0,1,0,0,0],\n        [0,0,0,1,0,0,0],\n        [0,1,1,1,1,1,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n    ])\n\n    # we're accepting a little error because for example \n    # the center pixel or the ending pixel may vary, \n    # depending on the implementation\n    assert np.abs(np.abs(result) - np.abs(reference)).sum() <= 3"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "prompt": "def combine_columns_of_tables(dataframe1, dataframe2, index):\n    \"\"\"\n    This function combines to dataframes and makes sure the data is merged \n    using the given index column, which must be present in both dataframes.\n    The dataframes should be merged in a way that no data is lost and missing\n    fields are filled with NaN.\n    \"\"\"", "canonical_solution": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "entry_point": "combine_columns_of_tables", "test": "def check(candidate):\n    import pandas as pd\n    import numpy as np\n\n    table1 = pd.DataFrame({\n    \"label\":       [1,   2,   3],\n    \"circularity\": [0.3, 0.5, 0.7],\n    \"elongation\":  [2.3, 3.4, 1.2],\n    })\n\n    table2 = pd.DataFrame({\n    \"label\":    [3,   2,   1,   4],\n    \"area\":     [22,  32,  25,  18],\n    \"skewness\": [0.5, 0.6, 0.3, 0.3],\n    })\n\n    reference = pd.DataFrame({\n    \"label\":       [1,   2,   3,   4],\n    \"circularity\": [0.3, 0.5, 0.7, np.nan],\n    \"elongation\":  [2.3, 3.4, 1.2, np.nan],\n    \"area\":     [25,  32,  22,  18],\n    \"skewness\": [0.3, 0.6, 0.5, 0.3],\n    })\n    \n    result = candidate(table1, table2, \"label\")\n\n    comparison = result.compare(reference)\n    assert len(comparison.columns) == 0\n    assert len(comparison.index) == 0"}
{"task_id": "../test_cases/convolve_images.ipynb", "prompt": "def convolve_images(image, kernel_image):\n    \"\"\"\n    Convolve an image with a kernel_image and return the result\n    \"\"\"", "canonical_solution": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "entry_point": "convolve_images", "test": "def check(candidate):\n    import numpy as np\n\n    image = np.asarray([\n        [0,0,0,0,0,0,0],\n        [0,1,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,1,0,0],\n        [0,0,0,0,0,0,0],\n    ])\n    kernel= np.asarray([\n        [0,1,0],\n        [1,1,1],\n        [0,2,0],\n    ])\n\n    reference = np.asarray([\n        [0,1,0,0,0,0,0],\n        [1,1,1,0,0,0,0],\n        [0,2,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,1,0,0],\n        [0,0,0,1,1,1,0],\n        [0,0,0,0,2,0,0],\n    ])\n\n    result = candidate(image, kernel)\n    \n    assert np.allclose(reference, result)\n\n    \n    image = np.asarray([\n        [0,0,0,0,0,0,0],\n        [0,1,1,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n    ])\n\n    reference = np.asarray([\n        [0,1,1,0,0,0,0],\n        [1,2,2,1,0,0,0],\n        [0,2,2,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n        [0,0,0,0,0,0,0],\n    ])\n\n    result = candidate(image, kernel)\n    \n    assert np.allclose(reference, result)\n   \n"}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "prompt": "def count_number_of_touching_neighbors(label_image):\n    \"\"\"\n    Takes a label image and returns a list of number of touching neighbors \n    for each labeled object.\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "entry_point": "count_number_of_touching_neighbors", "test": "def check(candidate):\n    import numpy as np\n\n    label_image = np.asarray([\n        [0,0,0,0,0],\n        [0,0,2,2,0],\n        [0,0,1,3,0],\n        [0,4,1,0,0],\n        [0,0,0,0,0],\n    ])\n    print(candidate(label_image))\n    assert np.array_equal(candidate(label_image), [3, 2, 2, 1])"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "prompt": "def count_objects_over_time(binary_image_list):\n    \"\"\"\n    Takes a timelapse (list of binary images), counts the number of connected components and returns the resulting counts as list.\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "entry_point": "count_objects_over_time", "test": "def check(candidate):\n    import numpy as np\n\n    images = [\n        np.asarray([\n            [1,0,0,0],    \n            [0,0,0,0],    \n            [0,0,1,0],    \n            [0,0,0,0],            \n        ]),\n        np.asarray([\n            [1,0,0,0],    \n            [0,0,0,0],    \n            [0,0,1,1],    \n            [0,0,0,0],            \n        ]),\n        np.asarray([\n            [1,0,0,0],    \n            [0,0,0,0],    \n            [0,0,0,1],    \n            [0,1,0,0],            \n        ]),\n        np.asarray([\n            [1,1,0,0],    \n            [0,0,0,0],    \n            [0,0,0,1],    \n            [0,1,0,0],            \n        ]),\n        np.asarray([\n            [0,0,1,0],    \n            [1,0,0,0],    \n            [0,0,0,1],    \n            [0,1,0,0],            \n        ]),\n    ]\n    reference = [2,2,3,3,4]\n    \n    result = candidate(images) \n\n    assert np.allclose(reference, result)\n"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "prompt": "def count_overlapping_regions(label_image_1, label_image_2):\n    \"\"\"\n    Takes two label images and counts how many objects in label_image_1 overlap \n    with any label in label_image_2 with at least one pixel.\n    It returns the count of overlapping objects.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "entry_point": "count_overlapping_regions", "test": "def check(candidate):\n    import numpy as np\n\n    label_image_1 = np.asarray([\n        [0,1,0,0,0],\n        [0,0,2,0,0],\n        [0,0,0,3,0],\n        [0,4,4,0,0],\n        [0,0,0,5,0],\n    ])\n\n    label_image_2 = np.asarray([\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,1,0],\n        [0,0,1,0,0],\n        [0,0,0,1,0],\n    ])\n    \n    result = candidate(label_image_1, label_image_2) \n    assert result == 3\n\n    result = candidate(label_image_2, label_image_1)\n    assert result == 1\n"}
{"task_id": "../test_cases/create_umap.ipynb", "prompt": "def create_umap(dataframe):\n    \"\"\"\n    Takes a dataframe and computes a UMAP from all columns. \n    The two UMAP vectors are stored in the dataframe as `umap0` and `umap1`.\n    \"\"\"", "canonical_solution": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "entry_point": "create_umap", "test": "def check(candidate):\n    import pandas as pd\n    df = pd.DataFrame(\n        {\n         \"a\":[1.6,2.3,2.6,3.7,3.4,3.9,4.3,4.3,4.0,5.1,5.2,5.3,5.5], \n         \"b\":[0.1,0.2,0.3,0.3,0.4,0.4,0.4,0.5,0.5,0.5,0.6,0.6,0.6],\n         \"c\":[1.6,2.3,2.6,3.7,3.4,3.9,4.3,4.3,4.0,5.1,5.2,5.3,5.4],\n         \"d\":[1.7,2.4,2.4,3.6,3.5,3.9,4.4,4.2,4.1,5.0,5.1,5.4,5.6]\n        }\n    )\n    candidate(df)\n    \n    expected_columns = ['umap0', 'umap1']\n\n    # I'm not sure how to check if the umap columns contain a proper umap, \n    # but we can check if all expected columns exist.\n    for ec in expected_columns:\n        assert ec in df.columns"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "prompt": "def crop_quarter_image(image):\n    \"\"\"\n    Crops out the first half image in both dimensions (width and height). \n    The resulting image will be of quarter size compared to the original image.\n    \"\"\"", "canonical_solution": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "entry_point": "crop_quarter_image", "test": "def check(candidate):\n    import numpy as np\n\n    image = np.asarray([\n        [0,0,0,0,0,0],\n        [0,1,0,0,2,0],\n        [0,0,0,0,0,0],\n        [0,0,0,0,0,0],\n        [0,4,0,0,3,0],\n        [0,0,0,0,0,0],\n    ])\n\n    reference = np.asarray([\n        [0,0,0],\n        [0,1,0],\n        [0,0,0],\n    ])\n    \n    assert np.array_equal(candidate(image), reference)\n"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "prompt": "def expand_labels_without_overlap(label_image, radius:int=1):\n    \"\"\"\n    Takes a label_image and enlarges all labels by a given radius, without\n    labels overwriting each other.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "entry_point": "expand_labels_without_overlap", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,1,1,3,0],\n        [0,1,1,3,0],\n        [0,0,0,0,0],\n        [2,0,0,0,0],\n    ]))\n\n    reference = np.asarray([\n        [0,1,1,3,0],\n        [1,1,1,3,3],\n        [1,1,1,3,3],\n        [2,1,1,3,0],\n        [2,2,0,0,0],\n    ])\n\n    assert np.array_equal(reference, result)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "prompt": "def extract_surface_measure_area(binary_volume_image):\n    \"\"\"\n    Take a 3D binary_volume_image, extracts the surface of the white (voxel value != 0) object \n    and returns the surface area of the object.\n    \"\"\"", "canonical_solution": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "entry_point": "extract_surface_measure_area", "test": "def check(candidate):\n    import numpy as np\n    binary_volume_image = np.asarray([\n        [\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0],\n        ],[\n            [0,0,0,0],\n            [0,1,1,0],\n            [0,1,1,0],\n            [0,0,0,0],\n        ],[\n            [0,0,0,0],\n            [0,1,1,0],\n            [0,1,1,0],\n            [0,0,0,0],\n        ],[\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0],\n        ],\n    ])\n    assert abs(candidate(binary_volume_image) - 20) < 1\n\n    binary_volume_image = np.zeros((3,3,3))\n    binary_volume_image[1,1,1] = 1\n    assert abs(candidate(binary_volume_image) - 3) < 1\n"}
{"task_id": "../test_cases/fit_circle.ipynb", "prompt": "def fit_circle(list_of_2d_points):\n    \"\"\"\n    Implements 2D circle fitting\n    Input: Collection of 2d points, represented as a list of lists [ [x0,y0], [x1,y1], ... ]  \n    Output: Tuple: xc, yc, radius\n    \"\"\"", "canonical_solution": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "entry_point": "fit_circle", "test": "def check(candidate):\n    coordinates = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    xc, yc, r = candidate(coordinates)\n    tolerance = 0.05\n    assert xc > 0 - tolerance \n    assert xc < 0 + tolerance\n    assert yc > 0 - tolerance \n    assert yc < 0 + tolerance\n    assert r > 1 - tolerance \n    assert r < 1 + tolerance"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "prompt": "def label_binary_image_and_count_labels(binary_image):\n    \"\"\"\n    Consumes as input a binary image, applies connected component labeling to it, \n    counts the labeled objects and returns their count as single number.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "entry_point": "label_binary_image_and_count_labels", "test": "def check(candidate):\n    import numpy as np\n    \n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [1,0,0,0,0],\n        [0,0,0,1,0],\n    ])) == 3\n\n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n    ])) == 1\n\n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n    ])) == 0"}
{"task_id": "../test_cases/label_sequentially.ipynb", "prompt": "def label_sequentially(label_image):\n    \"\"\"\n    Takes a label_image with n labels and relabels the objects, \n    to make sure all integer labels between 0 and n are used. \n    No gaps are there.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "entry_point": "label_sequentially", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,4,0,0,0],\n        [0,0,5,0,0],\n        [0,0,0,6,0],\n    ])) \n\n    # -1 becaue background counts\n    assert len(np.unique(result)) - 1 == 4\n    assert result.max() == 4\n    assert result.shape[0] == 5\n    assert result.shape[1] == 5"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "prompt": "def list_image_files_in_folder(folder_location):\n    \"\"\"\n    Lists all image files in a folder.\n    \"\"\"", "canonical_solution": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "entry_point": "list_image_files_in_folder", "test": "def check(candidate):\n    list_files = candidate(\"../example_data/S-BIAD634/images_and_stuff/\")\n    \n    assert \"Ganglioneuroblastoma_8.tif\" in list_files\n    assert \"Ganglioneuroblastoma_9.tif\" in list_files\n    assert \"Ganglioneuroblastoma_10.tif\" in list_files\n    assert len(list_files) == 3"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "prompt": "def map_pixel_count_of_labels(label_image):\n    \"\"\"\n    Takes a label_image, determines the pixel-count per label and creates an image where the label values are replaced by the corresponding pixel count.\n    \"\"\"", "canonical_solution": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "entry_point": "map_pixel_count_of_labels", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,0,0,0],\n        [1,2,2,0,0],\n        [1,2,2,0,0],\n        [1,0,0,3,0],\n        [0,0,0,4,0],\n    ]))\n\n    reference = np.asarray([\n        [0,0,0,0,0],\n        [3,4,4,0,0],\n        [3,4,4,0,0],\n        [3,0,0,1,0],\n        [0,0,0,1,0],\n    ])\n\n    assert np.array_equal(reference, result)"}
{"task_id": "../test_cases/mask_image.ipynb", "prompt": "def mask_image(image, mask):\n    \"\"\"\n    Takes a 2D input image and a 2D binary mask image, then applies the mask to the input image and returns the result.\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "entry_point": "mask_image", "test": "def check(candidate):\n    import numpy as np\n    \n    image = [\n        [2,2,2,2,2],\n        [2,2,3,2,2],\n        [2,3,3,3,2],\n        [2,2,3,2,2],\n        [2,2,2,2,2],\n    ]\n    mask = [\n        [0,0,0,0,0],\n        [0,0,1,0,0],\n        [0,1,1,1,0],\n        [0,0,1,0,0],\n        [0,0,0,0,0],\n    ]\n    reference = [\n        [0,0,0,0,0],\n        [0,0,3,0,0],\n        [0,3,3,3,0],\n        [0,0,3,0,0],\n        [0,0,0,0,0],\n    ]\n    masked_image = candidate(image,mask)\n    assert np.array_equal(masked_image, reference)"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "prompt": "def maximum_intensity_projection(image):\n    \"\"\"\n    Performs a maximum intensity projection along the first axis of an image.\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "entry_point": "maximum_intensity_projection", "test": "def check(candidate):\n    import numpy as np\n\n    image = np.asarray([\n        [0,0,0,0,0,0],\n        [0,1,0,0,2,0],\n        [0,0,0,0,0,0],\n        [0,0,0,0,0,0],\n        [0,4,0,0,3,0],\n        [0,0,0,0,0,0],\n    ])\n\n    reference = np.asarray(\n        [0,4,0,0,3,0]\n    )\n    \n    assert np.array_equal(candidate(image), reference)\n"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "prompt": "def mean_squared_error(image1, image2):\n    \"\"\"\n    Computes the mean-squared-error of two images compared pixel-by-pixel\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "entry_point": "mean_squared_error", "test": "def check(candidate):\n    image1 = [\n        [0,0,0,0,0],\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,2,0],\n        [0,0,0,0,0],\n    ]\n    image2 = [\n        [0,0,0,0,0],\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,2,0],\n        [0,0,0,0,0],\n    ]\n\n    mse = candidate(image1,image2)\n    print(mse)\n    assert mse == 0\n\n    image3 = [\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n    ]\n\n    mse = candidate(image1,image3)\n    print(mse)\n    assert mse == 5 / 25\n    \n"}
{"task_id": "../test_cases/mean_std_column.ipynb", "prompt": "def mean_std_column(dataframe, column:str):\n    \"\"\"\n    Computes the mean average and standard deviation of a specified column \n    in a given dataframe and returns these two values.\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "entry_point": "mean_std_column", "test": "def check(candidate):\n    import pandas as pd\n    df = pd.DataFrame(\n        {\n         \"a\":[1.6,2.3,2.6,3.7,3.4,3.9,4.3,4.3,4.0,5.1,5.2,5.3,5.5], \n         \"b\":[0.1,0.2,0.3,0.3,0.4,0.4,0.4,0.5,0.5,0.5,0.6,0.6,0.6],\n         \"c\":[1.6,2.3,2.6,3.7,3.4,3.9,4.3,4.3,4.0,5.1,5.2,5.3,5.4],\n         \"d\":[1.7,2.4,2.4,3.6,3.5,3.9,4.4,4.2,4.1,5.0,5.1,5.4,5.6]\n        }\n    )\n    \n    result_mean, result_std = candidate(df, \"a\")\n    assert abs(result_mean - 3.938) < 0.001\n    assert abs(result_std - 1.170) < 0.001\n\n\n    result_mean, result_std = candidate(df, \"b\")\n    assert abs(result_mean - 0.415) < 0.001\n    assert abs(result_std - 0.151) < 0.001\n\n    result_mean, result_std = candidate(df, \"c\")\n    assert abs(result_mean - 3.931) < 0.001\n    assert abs(result_std - 1.160) < 0.001\n\n    result_mean, result_std = candidate(df, \"d\")\n    assert abs(result_mean - 3.946) < 0.001\n    assert abs(result_std - 1.168) < 0.001\n"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "prompt": "def measure_aspect_ratio_of_regions(label_image):\n    \"\"\"\n    Takes a label image and returns a pandas dataframe\n    with measurements for aspect_ratio of the objects\n    \"\"\"", "canonical_solution": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "entry_point": "measure_aspect_ratio_of_regions", "test": "def check(candidate):\n    import numpy as np\n\n    label_image = np.asarray([\n        [0,1,1,0,0,3,3],\n        [0,1,1,0,0,3,3],\n        [0,2,2,2,2,3,3],\n        [0,2,2,2,2,3,3],\n        [0,4,4,4,0,3,3],\n        [0,4,4,4,0,3,3],\n        [0,4,4,4,0,0,0],\n    ])\n    \n    result = candidate(label_image) \n    print(result['aspect_ratio'])\n    assert np.allclose(result['aspect_ratio'], [1,2,3,1], atol=0.5)\n"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "prompt": "def measure_intensity_of_labels(label_image, intensity_image):\n    \"\"\"\n    Takes a label image and an intensity image, and returns a list of mean intensities \n    of all pixels in the intensity image, belonging to a given label.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "entry_point": "measure_intensity_of_labels", "test": "def check(candidate):\n    import numpy as np\n\n    label_image = np.asarray([\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,2,2,2,2],\n        [0,3,3,0,0],\n        [0,0,0,4,0],\n    ])\n\n    intensity_image = np.asarray([\n        [0,2,0,0,0],\n        [0,0,0,0,0],\n        [0,3,3,4,4],\n        [0,3,3,0,0],\n        [0,0,0,5,0],\n    ])\n    \n    result = candidate(label_image, intensity_image) \n    assert np.array_equal([2,3.5,3,5], result)"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "prompt": "def measure_mean_image_intensity(image):\n    \"\"\"\n    Takes an image and returns its mean intensity\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    return np.asarray(image).mean()", "entry_point": "measure_mean_image_intensity", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [1,2,3,4,5],\n        [1,2,3,4,5],\n        [1,2,3,4,5],\n        [1,2,3,4,5],\n        [1,2,3,4,5],\n    ])) \n    assert result == 3"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "prompt": "def measure_pixel_count_of_labels(label_image):\n    \"\"\"\n    Takes a label image and returns a list of counts of number of pixels per label.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "entry_point": "measure_pixel_count_of_labels", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,2,2,2,0],\n        [0,3,3,0,0],\n        [0,0,0,4,0],\n    ])) \n    assert np.array_equal([1,3,2,1], result)"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "prompt": "def open_image_return_dimensions(image_file_location):\n    \"\"\"\n    Opens an image and returns its dimensions\n    \"\"\"", "canonical_solution": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "entry_point": "open_image_return_dimensions", "test": "def check(candidate):\n    shape = candidate(\"../example_data/blobs.tif\")\n    \n    assert shape[0] == 254\n    assert shape[1] == 256\n"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "prompt": "def open_nifti_image(image_file_location):\n    \"\"\"\n    This function loads a nifti image from the file at image_location and returns the image data as a numpy array. \n    \"\"\"", "canonical_solution": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "entry_point": "open_nifti_image", "test": "def check(candidate):\n    import numpy as np\n\n    reference = np.ones((5, 5, 5), dtype=np.int16)\n\n    image_location = '../example_data/test3d.nii.gz'\n    data = candidate(image_location)\n    assert np.array_equal(data, reference)"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "prompt": "def pair_wise_correlation_matrix(dataframe):\n    \"\"\"\n    Takes a pandas dataframe and computes for all columns their Pearson's correlation coefficient\n    for all columns in the dataframe. For n columns, this is a n x n matrix of coefficients.\n    The matrix is returned as dataframe.\n    \"\"\"", "canonical_solution": "\n    return dataframe.corr()", "entry_point": "pair_wise_correlation_matrix", "test": "def check(candidate):\n    import pandas as pd\n    df = pd.DataFrame(\n        {\n         \"a\":[1.6,2.3,2.6,3.7,3.4,3.9,4.3,4.3,4.0,5.1,5.2,5.3,5.5], \n         \"b\":[0.1,0.2,0.3,0.3,0.4,0.4,0.4,0.5,0.5,0.5,0.6,0.6,0.6],\n         \"c\":[1.6,2.3,2.6,3.7,3.4,3.9,4.3,4.3,4.0,5.1,5.2,5.3,5.4],\n         \"d\":[1.7,2.4,2.4,3.6,3.5,3.9,4.4,4.2,4.1,5.0,5.1,5.4,5.6],\n         \"e\":[1.7,2.4,2.4,3.6,3.5,3.9,4.4,4.2,4.1,5.0,5.1,5.4,5.6]\n        }\n    )\n\n    result = candidate(df)\n\n    print(result)\n\n    assert 'a' in result.columns\n    assert 'b' in result.columns\n    assert 'c' in result.columns\n    assert 'd' in result.columns\n    assert 'e' in result.columns\n\n    assert abs(result['a'].iloc[0] - 1) < 0.0001\n    assert abs(result['b'].iloc[1] - 1) < 0.0001\n    assert abs(result['c'].iloc[2] - 1) < 0.0001\n    assert abs(result['d'].iloc[3] - 1) < 0.0001\n    assert abs(result['e'].iloc[4] - 1) < 0.0001\n\n    # columns d and e are identical\n    assert abs(result['e'].iloc[3] - 1) < 0.0001\n    \n    assert result.size == 25"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "prompt": "def radial_intensity_profile(image, xc, yc):\n    \"\"\"\n    Computes the radial intensity profile of an image around a given coordinate\n    Inputs:\n    - image: 2d numpy array\n    - xy, yc: the center coordinates\n    Output:\n    - an array containing the average intensities\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "entry_point": "radial_intensity_profile", "test": "def check(candidate):\n    import numpy as np\n    xc = 5\n    yc = 5 \n    x, y = np.indices(np.zeros(shape=(11,11)).shape)\n    distance_image = np.sqrt((x - xc)**2 + (y - yc)**2)\n    result = candidate(distance_image, xc, yc) \n    reference = [0, 1, 2, 3, 4, 5]\n    \n    assert np.allclose(reference, result[0:len(reference)], atol=0.5)"}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "prompt": "def region_growing_segmentation(image, point):\n    \"\"\"\n    Segments an image using the region-growing/flood filling \n    starting from a single point.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "entry_point": "region_growing_segmentation", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n        [1,1,1,1,1,1,1,1,1,1],\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n        [1,1,1,1,1,1,1,1,1,1],\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n    ]), (5,5)) \n\n    assert result.sum() * 1 == 16\n    assert result.min() == 0\n    assert result.max() == 1"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "prompt": "def remove_labels_on_edges(label_image):\n    \"\"\"\n    Takes a label_image and removes all objects which touch the image border.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "entry_point": "remove_labels_on_edges", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,0,0,0],\n        [1,2,2,0,0],\n        [1,2,2,0,0],\n        [1,0,0,3,0],\n        [0,0,0,4,0],\n    ]))\n\n    # -1 becaue background counts\n    assert len(np.unique(result)) - 1 == 2\n    assert result.shape[0] == 5\n    assert result.shape[1] == 5"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "prompt": "def remove_noise_edge_preserving(image, radius:int=1):\n    \"\"\"\n    Applies an edge-preserving noise-removal filter to an image.\n    \"\"\"", "canonical_solution": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "entry_point": "remove_noise_edge_preserving", "test": "def check(candidate):\n    import numpy as np\n\n    image = np.asarray([\n        [1,1,2,2,2],\n        [1,2,2,2,2],\n        [1,1,2,2,2],\n        [1,1,1,2,2],\n        [1,1,2,2,2],\n    ])\n\n    reference = np.asarray([\n        [1,1,2,2,2],\n        [1,1,2,2,2],\n        [1,1,2,2,2],\n        [1,1,2,2,2],\n        [1,1,2,2,2],\n    ])\n    \n    assert np.array_equal(candidate(image), reference)\n\n    assert candidate(image, radius=5).mean() == 2\n\n"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "prompt": "def remove_small_labels(label_image, size_threshold:int=0):\n    \"\"\"\n    Takes a label_image and removes all objects that are smaller than a given size_threshold.\n    \"\"\"", "canonical_solution": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "entry_point": "remove_small_labels", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,0,0,0],\n        [1,2,2,0,0],\n        [1,2,2,0,0],\n        [1,0,0,3,0],\n        [0,0,0,4,0],\n    ]), size_threshold=2)\n\n    reference = np.asarray([\n        [0,0,0,0,0],\n        [1,2,2,0,0],\n        [1,2,2,0,0],\n        [1,0,0,0,0],\n        [0,0,0,0,0],\n    ])\n\n    assert np.array_equal(reference, result)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "prompt": "def return_hello_world():\n    \"\"\"\n    Returns the string \"hello world\".\n    \"\"\"", "canonical_solution": "\n    return \"hello world\"", "entry_point": "return_hello_world", "test": "def check(candidate):\n    assert candidate() == \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "prompt": "def rgb_to_grey_image_transform(rgb_image, r:float, g:float, b:float):\n    \"\"\"\n    Convert an RGB image to a single-channel gray scale image with \n    configurable weights r, g and b.\n    The weights are normalized to be 1 in sum.\n    \"\"\"", "canonical_solution": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "entry_point": "rgb_to_grey_image_transform", "test": "def check(candidate):\n    import numpy as np\n    assert np.allclose(candidate([[[0,1,2], [3,3,3]]], 0.5, 0.25, 0.25),\n                                     [[0.75,  3]], atol=0.0001)\n\n    assert np.allclose(candidate([[[0,1,2], [3,3,3]]], 1, 2, 2),\n                                     [[1.2,  3]], atol=0.0001)\n                          "}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "prompt": "def rotate_image_by_90_degrees(image):\n    \"\"\"\n    Rotates an image by 90 degrees clockwise around the center of the image.\n    \"\"\"", "canonical_solution": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "entry_point": "rotate_image_by_90_degrees", "test": "def check(candidate):\n    import numpy as np\n\n    image = np.asarray([\n        [0,0,0,0,0,0],\n        [0,1,0,0,2,0],\n        [0,0,0,0,0,0],\n        [0,0,0,0,0,0],\n        [0,4,0,0,3,0],\n        [0,0,0,0,0,0],\n    ])\n\n    reference = np.asarray([\n        [0,0,0,0,0,0],\n        [0,4,0,0,1,0],\n        [0,0,0,0,0,0],\n        [0,0,0,0,0,0],\n        [0,3,0,0,2,0],\n        [0,0,0,0,0,0],\n    ])\n    \n    assert np.array_equal(candidate(image), reference)\n"}
{"task_id": "../test_cases/subsample_image.ipynb", "prompt": "def subsample_image(image, n:int=2):\n    \"\"\"\n    Subsamples an image by skipping every n'th pixel in X and Y.\n    \"\"\"", "canonical_solution": "\n    return image[::n,::n]", "entry_point": "subsample_image", "test": "def check(candidate):\n    import numpy as np\n\n    image = np.asarray([\n        [1,2,3,4,5,6],\n        [7,8,9,0,1,2],\n        [3,4,5,6,7,8],\n        [9,0,1,2,3,4],\n        [5,6,7,8,9,0],\n        [1,2,3,4,5,6],\n    ])\n\n    reference = np.asarray([\n        [1,3,5],\n        [3,5,7],\n        [5,7,9],\n    ])\n    \n    assert np.array_equal(candidate(image, n=2), reference)\n\n    reference = np.asarray([\n        [1,4],\n        [9,2],\n    ])\n\n    assert np.array_equal(candidate(image, n=3), reference)"}
{"task_id": "../test_cases/sum_images.ipynb", "prompt": "def sum_images(image1, image2):\n    \"\"\"\n    Sums two images pixel-by-pixel and returns the result\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "entry_point": "sum_images", "test": "def check(candidate):\n    import numpy as np\n\n    image1 = np.random.random((5,6))\n    image2 = np.random.random((5,6))\n    sum_image = image1 + image2\n    \n    assert np.allclose(candidate(image1, image2), sum_image)\n\n    image1 =    [[1,2,3], [4,5,6]]\n    image2 =    [[5,6,7], [0,1,2]]\n    sum_image = [[6,8,10],[4,6,8]]\n    \n    assert np.allclose(candidate(image1, image2), sum_image)\n"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "prompt": "def tiled_image_processing(image, radius, tile_size):\n    \"\"\"\n    Apply a maximum filter with a given radius to the image using a tile-by-tile strategy.\n    The tile_size denotes the size of the tiles in X and Y.\n    \"\"\"", "canonical_solution": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "entry_point": "tiled_image_processing", "test": "def check(candidate):\n    import numpy as np\n\n    image = np.asarray([\n        [0,0,0,0,0,0],\n        [1,0,0,1,0,0],\n        [0,0,0,0,0,0],\n        [0,0,2,0,0,0],\n        [0,0,0,1,0,0],\n        [0,0,0,0,0,0],\n    ])\n\n    # this reference image has tile-border artefacts,\n    # the maximum-filter does not consider pixels beyond\n    # the 3x3 border\n    reference = np.asarray([\n        [1,1,0,1,1,0],\n        [1,1,0,1,1,0],\n        [1,1,0,1,1,0],\n        [0,2,2,1,1,0],\n        [0,2,2,1,1,0],\n        [0,0,0,1,1,0],\n    ])\n\n    result = candidate(image, 1, 3)\n\n    assert np.array_equal(result, reference)"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "prompt": "def transpose_image_axes(image):\n    \"\"\"\n    Transposes the first two axes of an image.\n    \"\"\"", "canonical_solution": "\n    import numpy as np\n    return np.asarray(image).T", "entry_point": "transpose_image_axes", "test": "def check(candidate):\n    import numpy as np\n\n    image = np.asarray([\n        [0,0,0,0,0,0],\n        [0,1,0,0,2,0],\n        [0,0,0,0,0,0],\n        [0,0,0,0,0,0],\n        [0,4,0,0,3,0],\n        [0,0,0,0,0,0],\n    ])\n\n    reference = np.asarray([\n        [0,0,0,0,0,0],\n        [0,1,0,0,4,0],\n        [0,0,0,0,0,0],\n        [0,0,0,0,0,0],\n        [0,2,0,0,3,0],\n        [0,0,0,0,0,0],\n    ])\n    \n    assert np.array_equal(candidate(image), reference)\n"}
{"task_id": "../test_cases/t_test.ipynb", "prompt": "def t_test(dataframe, column1:str, column2:str):\n    \"\"\"\n    Takes two specified columns from a given dataframe and applies a paired T-test to it to determine the p-value.\n    \"\"\"", "canonical_solution": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "entry_point": "t_test", "test": "def check(candidate):\n    import pandas as pd\n    df = pd.DataFrame(\n        {\n         \"a\":[1.6,2.3,2.6,3.7,3.4,3.9,4.3,4.3,4.0,5.1,5.2,5.3,5.5], \n         \"b\":[0.1,0.2,0.3,0.3,0.4,0.4,0.4,0.5,0.5,0.5,0.6,0.6,0.6],\n         \"c\":[1.6,2.3,2.6,3.7,3.4,3.9,4.3,4.3,4.0,5.1,5.2,5.3,5.4],\n         \"d\":[1.7,2.4,2.4,3.6,3.5,3.9,4.4,4.2,4.1,5.0,5.1,5.4,5.6]\n        }\n    )\n    \n    result = candidate(df, \"a\",\"b\")\n    assert 6e-8 > result > 5e-8\n\n    result = candidate(df, \"a\",\"c\")\n    assert 0.4 > result > 0.3\n"}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "prompt": "def workflow_batch_process_folder_count_labels(folder_location):\n    \"\"\"\n    This functions goes through all .tif image files in a specified folder, \n    loads the images and count labels each image. \n    It returns a dictionary with filenames and corresponding counts.\n    \"\"\"", "canonical_solution": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "entry_point": "workflow_batch_process_folder_count_labels", "test": "def check(candidate):\n    counts = candidate(\"../example_data/S-BIAD634/groundtruth/\")\n\n    assert counts[\"Ganglioneuroblastoma_0.tif\"] == 300\n    assert counts[\"Ganglioneuroblastoma_1.tif\"] == 398\n    assert counts[\"Ganglioneuroblastoma_2.tif\"] == 368\n    assert counts[\"Ganglioneuroblastoma_3.tif\"] == 378\n    assert counts[\"Ganglioneuroblastoma_4.tif\"] == 363\n    assert len(counts.keys()) == 5"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "prompt": "def workflow_batch_process_folder_measure_intensity(image_folder_location, labels_folder_location):\n    \"\"\"\n    This functions goes through all .tif image files in a specified image folder \n    and corresponding label images in another labels folder. \n    It loads the images and corresponding labels, and measures min, mean and max intensity of all labels.\n    The function returns a dataframe with five columns: min_intensity, mean_intensity, max_intensity, label and filename.\n    \"\"\"", "canonical_solution": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "entry_point": "workflow_batch_process_folder_measure_intensity", "test": "def check(candidate):\n    label_stats = candidate(\"../example_data/S-BIAD634/images/\", \"../example_data/S-BIAD634/groundtruth/\")\n\n    assert label_stats['label'].max() == 398\n    assert label_stats['min_intensity'].min() == 7\n    assert label_stats['max_intensity'].max() == 255\n\n    assert label_stats.size == 9035\n    \n    assert abs(label_stats['mean_intensity'].max() - 186) < 1\n\n    assert len(label_stats.columns) == 5\n    assert len(label_stats['mean_intensity']) == 1807\n\n    assert \"filename\" in label_stats.columns\n    assert \"label\" in label_stats.columns\n    assert \"min_intensity\" in label_stats.columns\n    assert \"mean_intensity\" in label_stats.columns\n    assert \"max_intensity\" in label_stats.columns"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "prompt": "def workflow_segmentation_counting(image):\n    \"\"\"\n    This function segments objects in an image with intensity above average \n    and returns their count.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "entry_point": "workflow_segmentation_counting", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,1,0,0,0],\n        [0,0,0,2,0],\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n    ])) \n    assert result == 3\n\n    result = candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,100,0,90,0],\n        [0,0,0,0,0],\n        [0,110,0,80,0],\n        [0,0,0,0,0],\n    ])) \n    assert result == 4"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "prompt": "def workflow_segmentation_measurement_summary(image):\n    \"\"\"\n    This function implements a workflow consisting of these steps:\n    * threshold intensity input image using Otsu's method\n    * label connected components\n    * measure area of the labeled objects\n    * determine mean area of all objects\n    \"\"\"", "canonical_solution": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "entry_point": "workflow_segmentation_measurement_summary", "test": "def check(candidate):\n    import numpy as np\n    \n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [1,1,1,0,0],\n        [1,1,1,0,0],\n        [1,1,0,0,0],\n        [0,0,0,0,0],\n    ])) == 8\n\n    assert candidate(np.asarray([\n        [1,1,0,1,1],\n        [1,1,0,0,0],\n        [0,0,0,1,1],\n        [1,1,0,1,1],\n        [0,0,0,0,0],\n    ])) == 3\n\n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,1,0,1,0],\n        [0,0,0,0,0],\n        [0,0,1,0,0],\n        [0,0,0,0,0],\n    ])) == 1"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "prompt": "def workflow_watershed_segmentation_correction_measurement(image):\n    \"\"\"\n    This function implements a workflow consisting of these steps:\n    * blurs the image a bit\n    * detect local minima in the blurred image\n    * apply watershed segmentation flooding the blurred image from the \n      detected minima to retrieve a label image\n    * remove all objects which touch the image border\n    * measure the area of all remaining objects together\n    \"\"\"", "canonical_solution": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "entry_point": "workflow_watershed_segmentation_correction_measurement", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n        [1,1,1,1,1,1,1,1,1,1],\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n        [1,1,1,1,1,1,1,1,1,1],\n        [0,0,1,0,0,0,0,1,0,0],\n        [0,0,1,0,0,0,0,1,0,0],\n    ])) \n\n    # if only the 4x4 pixels are segmented:\n    assert result >= 16\n    # if it also considers borders as part of the center object:\n    assert result <= 36 \n"}
