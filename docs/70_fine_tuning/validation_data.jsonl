{"messages": [{"role": "user", "content": "def apply_otsu_threshold_and_count_postiive_pixels(image):\n    \"\"\"\n    Takes an image, applies Otsu's threshold method to it to create a binary image and \n    counts the positive pixels.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}]}
{"messages": [{"role": "user", "content": "def convex_hull_measure_area(point_cloud):\n    \"\"\"\n    Take a 3D point_cloud, determines the convex hull around the points and returns the surface area of the convex hull.\n    \"\"\""}, {"role": "assistant", "content": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}]}
{"messages": [{"role": "user", "content": "def measure_properties_of_regions(label_image, intensity_image):\n    \"\"\"\n    Takes a label image and an intensity image, and returns pandas dataframe\n    with measurements for area, perimeter and mean_intensity.\n    \"\"\""}, {"role": "assistant", "content": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}]}
{"messages": [{"role": "user", "content": "def detect_edges(image):\n    \"\"\"\n    Applies an edge-detection filter to an image.\n    \"\"\""}, {"role": "assistant", "content": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}]}
{"messages": [{"role": "user", "content": "def open_zarr(zarr_file_location):\n    \"\"\"\n    Opens a zarr file and returns the array\n    \"\"\""}, {"role": "assistant", "content": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}]}
{"messages": [{"role": "user", "content": "def workflow_segment_measure_umap(image):\n    \"\"\"\n    This function takes a single channel intensity image, \n    segments objects with intensity above half the maximum intensity, \n    labels connected components, \n    measures area, perimeter, mean_intensity, minor and major axis of the labeled objects, \n    and produces a UMAP from the given measurements. \n    The two UMAP vectors are saved as `umap0` and `umap1` togther with the measurements in a dataframe. \n    The function returns this dataframe.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}]}
{"messages": [{"role": "user", "content": "def measure_intensity_over_time(image_list):\n    \"\"\"\n    Takes a timelapse (list of images), measures the average intensity over time and returns the resulting measurements as list.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}]}
{"messages": [{"role": "user", "content": "def open_image_read_voxel_size(image_filename):\n    \"\"\"\n    Reads an image file and return its voxel size in Z-Y-X order.\n    \"\"\""}, {"role": "assistant", "content": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}]}
{"messages": [{"role": "user", "content": "def subtract_background_tophat(image, radius:int=1):\n    \"\"\"\n    Applies a top-hat filter with a given radius to an image with dark background (low values) and bright foreground (high values).\n    \"\"\""}, {"role": "assistant", "content": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}]}
{"messages": [{"role": "user", "content": "def deconvolve_image(image, kernel_image):\n    \"\"\"\n    Deconvolve an image with a kernel_image and return the result.\n    \"\"\""}, {"role": "assistant", "content": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}]}
{"messages": [{"role": "user", "content": "def sum_intensity_projection(image):\n    \"\"\"\n    Performs a maximum intensity projection along the first axis of an image.\n    \"\"\""}, {"role": "assistant", "content": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}]}
{"messages": [{"role": "user", "content": "def bland_altman(dataframe, column1:str, column2:str):\n    \"\"\"\n    Takes two specified columns from a given dataframe and applies Bland-Altman-Analysis to them.\n    Therefore, it adds two new columns, one called 'mean' containing the mean of the two corresponding values,\n    and one called 'diff' containing the difference between the two.\n    \"\"\""}, {"role": "assistant", "content": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}]}
